// To run: NODE_ENV=test npx jest
import * as userService from '../services/userService';
import User from '../models/user';
import jwt from 'jsonwebtoken';
import bcrypt from 'bcrypt';
import { IUser } from '../types/types';

// Mock dependencies
jest.mock('../models/user');
jest.mock('jsonwebtoken');
jest.mock('bcrypt');

describe('userService', () => {
    afterEach(() => {
        jest.clearAllMocks();
    });

    describe('authenticateUser', () => {
        it('should authenticate a user and return user details with a token', async () => {
            const credentials: IUser = {
                _id: '', // Dummy value, not used by authenticateUser
                username: '', // Dummy value, not used by authenticateUser
                email: 'test@example.com',
                password: 'password123',
            };

            const mockUser = {
                _id: 'user123',
                email: 'test@example.com',
                username: 'testuser',
                password: 'hashedpassword',
            };

            const mockToken = 'mocked.jwt.token';

            (User.findUserByEmail as jest.Mock).mockResolvedValue(mockUser);
            (bcrypt.compare as jest.Mock).mockResolvedValue(true);
            (jwt.sign as jest.Mock).mockReturnValue(mockToken);

            const result = await userService.authenticateUser(credentials);

            expect(User.findUserByEmail).toHaveBeenCalledWith('test@example.com');
            expect(bcrypt.compare).toHaveBeenCalledWith('password123', 'hashedpassword');
            expect(jwt.sign).toHaveBeenCalledWith(
                { userId: 'user123', email: 'test@example.com' },
                process.env.JWT_SECRET || 'default_secret',
                { expiresIn: '24h' }
            );
            expect(result).toEqual({
                user: {
                    _id: 'user123',
                    username: 'testuser',
                    email: 'test@example.com',
                },
                token: mockToken,
            });
        });

        it('should throw an error if the user is not found', async () => {
            const credentials: IUser = {
                _id: '', // Dummy value, not used by authenticateUser
                username: '', // Dummy value, not used by authenticateUser
                email: 'test@example.com',
                password: 'password123',
            };

            (User.findUserByEmail as jest.Mock).mockResolvedValue(null);

            await expect(userService.authenticateUser(credentials)).rejects.toThrow('Invalid credentials');

            expect(User.findUserByEmail).toHaveBeenCalledWith('test@example.com');
            expect(bcrypt.compare).not.toHaveBeenCalled();
            expect(jwt.sign).not.toHaveBeenCalled();
        });

        it('should throw an error if the password is invalid', async () => {
            const credentials: IUser = {
                _id: '', // Dummy value, not used by authenticateUser
                username: '', // Dummy value, not used by authenticateUser
                email: 'test@example.com',
                password: 'wrongpassword',
            };

            const mockUser = {
                _id: 'user123',
                email: 'test@example.com',
                username: 'testuser',
                password: 'hashedpassword',
            };

            (User.findUserByEmail as jest.Mock).mockResolvedValue(mockUser);
            (bcrypt.compare as jest.Mock).mockResolvedValue(false);

            await expect(userService.authenticateUser(credentials)).rejects.toThrow('Invalid credentials');

            expect(User.findUserByEmail).toHaveBeenCalledWith('test@example.com');
            expect(bcrypt.compare).toHaveBeenCalledWith('wrongpassword', 'hashedpassword');
            expect(jwt.sign).not.toHaveBeenCalled();
        });
    });

    describe('registerUser', () => {
        it('should register a new user and return user details with a token', async () => {
            const userData: IUser = {
                _id: '', // Will be generated by the database, so can be empty
                username: 'newuser',
                email: 'newuser@example.com',
                password: 'password123',
            };

            const mockHashedPassword = 'hashedpassword123';
            const mockNewUser = {
                _id: 'newuser123',
                username: 'newuser',
                email: 'newuser@example.com',
                password: mockHashedPassword,
            };

            const mockToken = 'mocked.jwt.token';

            (User.findUserByEmail as jest.Mock).mockResolvedValue(null);
            (User.findUserByUsername as jest.Mock).mockResolvedValue(null);
            (bcrypt.genSalt as jest.Mock).mockResolvedValue('salt');
            (bcrypt.hash as jest.Mock).mockResolvedValue(mockHashedPassword);
            (User.createUser as jest.Mock).mockResolvedValue(mockNewUser);
            (jwt.sign as jest.Mock).mockReturnValue(mockToken);

            const result = await userService.registerUser(userData);

            expect(User.findUserByEmail).toHaveBeenCalledWith('newuser@example.com');
            expect(User.findUserByUsername).toHaveBeenCalledWith('newuser');
            expect(bcrypt.genSalt).toHaveBeenCalledWith(10);
            expect(bcrypt.hash).toHaveBeenCalledWith('password123', 'salt');
            expect(User.createUser).toHaveBeenCalledWith({
                username: 'newuser',
                email: 'newuser@example.com',
                password: mockHashedPassword,
            });
            expect(jwt.sign).toHaveBeenCalledWith(
                { userId: 'newuser123', email: 'newuser@example.com' },
                process.env.JWT_SECRET || 'default_secret',
                { expiresIn: '24h' }
            );
            expect(result).toEqual({
                user: {
                    _id: 'newuser123',
                    username: 'newuser',
                    email: 'newuser@example.com',
                },
                token: mockToken,
            });
        });

        it('should throw an error if required fields are missing', async () => {
            const userData: IUser = {
                _id: '',
                username: '',
                email: 'newuser@example.com',
                password: 'password123',
            };

            await expect(userService.registerUser(userData)).rejects.toThrow('validation failed: All fields are required');

            expect(User.findUserByEmail).not.toHaveBeenCalled();
            expect(User.findUserByUsername).not.toHaveBeenCalled();
            expect(bcrypt.genSalt).not.toHaveBeenCalled();
            expect(bcrypt.hash).not.toHaveBeenCalled();
            expect(User.createUser).not.toHaveBeenCalled();
            expect(jwt.sign).not.toHaveBeenCalled();
        });

        it('should throw an error if a user with the email already exists', async () => {
            const userData: IUser = {
                _id: '',
                username: 'newuser',
                email: 'existing@example.com',
                password: 'password123',
            };

            const existingUser = {
                _id: 'existing123',
                email: 'existing@example.com',
                username: 'existinguser',
            };

            (User.findUserByEmail as jest.Mock).mockResolvedValue(existingUser);
            (User.findUserByUsername as jest.Mock).mockResolvedValue(null);

            await expect(userService.registerUser(userData)).rejects.toThrow('validation failed: User with this email or username already exists');

            expect(User.findUserByEmail).toHaveBeenCalledWith('existing@example.com');
            expect(User.findUserByUsername).toHaveBeenCalledWith('newuser');
            expect(bcrypt.genSalt).not.toHaveBeenCalled();
            expect(bcrypt.hash).not.toHaveBeenCalled();
            expect(User.createUser).not.toHaveBeenCalled();
            expect(jwt.sign).not.toHaveBeenCalled();
        });

        it('should throw an error if a user with the username already exists', async () => {
            const userData: IUser = {
                _id: '',
                username: 'existinguser',
                email: 'newuser@example.com',
                password: 'password123',
            };

            const existingUser = {
                _id: 'existing123',
                email: 'other@example.com',
                username: 'existinguser',
            };

            (User.findUserByEmail as jest.Mock).mockResolvedValue(null);
            (User.findUserByUsername as jest.Mock).mockResolvedValue(existingUser);

            await expect(userService.registerUser(userData)).rejects.toThrow('validation failed: User with this email or username already exists');

            expect(User.findUserByEmail).toHaveBeenCalledWith('newuser@example.com');
            expect(User.findUserByUsername).toHaveBeenCalledWith('existinguser');
            expect(bcrypt.genSalt).not.toHaveBeenCalled();
            expect(bcrypt.hash).not.toHaveBeenCalled();
            expect(User.createUser).not.toHaveBeenCalled();
            expect(jwt.sign).not.toHaveBeenCalled();
        });
    });
});